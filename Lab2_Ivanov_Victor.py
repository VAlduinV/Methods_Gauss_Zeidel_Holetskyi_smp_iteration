import numpy as np
import timeit
from math import dist
from pprint import pprint
#######################################################################################################################
code_to_test = """
import numpy as np
import timeit
from math import dist
from pprint import pprint

print("Завдання а)", "Метод Гаусса")

print('---------------------------------------------------------------------------------------------------------------')


def Gauss(X: [int, float], Y: [int, float]):
    Z = np.linalg.solve(X, Y)
    for i, e in enumerate(Z):
        print("Корені:", "x =", i, e)


X = np.matrix('2 -1 1; 3 3 -5; 1 3 -2')
Y = np.matrix('0; 1; 4')
Gauss(X, Y)
print('---------------------------------------------------------------------------------------------------------------')

print("Завдання б)")


def Choletskyi(G: [int, float], D: [int, float]):
    print("Перевірка симетричності:", np.all(G == G.T))
    H = np.linalg.solve(G, D)
    print(H)
    n = 3
    c = np.array([9.8, 6.7, 5.8])
    b = np.zeros((n, n))
    t = np.eye(n)
    y = np.zeros((n))
    x = np.zeros((n))

    for i in range(n):
        b[i][0] = G[i][0]
        t[0][i] = G[0][i] / b[0][0]

    for k in range(1, n):
        for i in range(k, n):
            s = 0
            for m in range(k):
                s = s + b[i][m] * t[m][k]
            b[i][k] = G[i][k] - s
        for j in range(k + 1, n):
            s = 0
            for m in range(k):
                s = s + b[k][m] * t[m][j]
            t[k][j] = (G[k][j] - s) / b[k][k]

    print("Матриця B:", b)
    print("Матриця C:", t)

    y[0] = c[0] / b[0][0]
    for i in range(1, n):
        s = 0
        for m in range(i):
            s = s + b[i][m] * y[m]
        y[i] = (c[i] - s) / b[i][i]
    print("Вектор y:", y)

    x[n - 1] = y[n - 1]
    for i in range(n - 1, -1, -1):
        s = 0
        for m in range(i + 1, n):
            s = s + t[i][m] * x[m]
        x[i] = y[i] - s
    print("Вектор x:", x)
    if H.all() == x.all():
        print("Метод Гаусса співпав з загальним методом Холецького:", True)
    else:
        print("Щось не так!")


G = np.array([[9.1, 5.6, 7.8],
              [3.8, 5.1, 2.8],
              [4.1, 5.7, 1.2]])
D = np.array([9.8, 6.7, 5.8])
Choletskyi(G, D)

print("Завдання с)", "Метод квадратних коренів")
print('##############################################################################################################')


def method_sqrt_roots(A: [float, int], B: [float, int]):
    '''
        Документація кода
        Вирішуємо систему Ax = B
        A = T'T
        Це розкладання може застосовуватися для вирішення системи лінійних рівнянь Ax = b,
        якщо матриця A симетрична та позитивно визначена. Такі матриці часто виникають,
        наприклад, при використанні методу найменших квадратів та чисельному розв'язанні диференціальних рівнянь.
        Якщо матриця системи є симетричною та позитивно визначеною,
        то для вирішення системи застосовують метод Холецького (метод квадратного коріння).
        В основі методу лежить алгоритм спеціального LU -розкладання матриці A ,
        внаслідок чого вона наводиться до виду A=LL'.
        Якщо розкладання отримано, те, як і методі LU -розкладання,
        рішення системи зводиться до послідовному розв'язанню двох систем з трикутними матрицями: і .
        Для знаходження коефіцієнтів матриці L невідомі коефіцієнти матриці прирівнюють відповідним елементам матриці A.
        Потім послідовно знаходять необхідні коефіцієнти за формулами:
        l_11 = sqrt(a_11),
        l_i1 = a_i1 / l_11, i = 2, 3, ..., m
        l_22 = sqrt(a_22 - (l_21)**2), l_i2 = (a_i2 - l_i1*l_21, i = 3, 4, ..., m
        l_kk = sqrt(a_kk - (l_k1)**2 - (l_k2)**2 -...-- (l_k,k-1)**2),
        l_ik = (a_ik - l_i1*l_k1 - l_i2*l_k2 - ... - l_ik-1,l_k,k-1)/l_kk, i = k+1, ..., m
        l_mm = sqrt(a_mm - (l_m1)**2 - (l_m2)**2 - ... - (l_m,m-1)**2)
    '''
    T = np.linalg.cholesky(A)
    print("Знайдемо розклад Холецького: ", T)
    T_TRANSPOSE = T.transpose()
    print("Транспонована матриця:", T_TRANSPOSE)
    # T' * B = y
    # T_TRANSPOSE' * y  = x
    y = np.linalg.inv(T) * B
    x = np.linalg.inv(T_TRANSPOSE) * y
    print("Перевірка симетричності:", np.all(A == A.T))
    for index, el in enumerate(x.round(4)):
        print("Корені:", "x =", index, el)
    for ii, ell in enumerate(y.round(4)):
        print("Корені:", "y =", ii, ell)


A = np.matrix('1, 0.5, 0.3333, 0.25; 0.5, 0.3333, 0.25, 0.2; 0.3333, 0.25, 0.2, 0.1667; 0.25, 0.2, 0.1667, 0.1429')
B = np.matrix('1; 0; 0; 0')
method_sqrt_roots(A, B)
print('##############################################################################################################')

print("Завдання г)", "Метод простої ітерації та метод Зейделя")


# Ax = b. Метод Зейделя
# Method 1
def Seidel_dist(a: [int, float], b: [int, float]):
    '''
        Що таке dist () у Python?
        Метод dist() у Python використовується для визначення евклідової відстані між двома точками p і q,
        кожна з яких задана як послідовність (або повторювана) координат .
        Дві точки повинні мати однаковий розмір. Цей метод є новим у Python версії 3.8. Синтаксис: math.dist(p, q)
    '''
    x, y, n = b, [0] * len(b), 0
    while dist(x, y) > 1e-4:
        x, y, n = [0] * len(x), x, n + 1
        for i in range(len(y)):
            x[i] = 1 / a[i][i] * (b[i] -
                                  sum(x[j] * a[i][j] for j in range(i)) -
                                  sum(y[j] * a[i][j] for j in range(i + 1, len(y))))

    # x = (2.12, 0.76, 1.30, -0.73) итераций: 12
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')


# Method 2
def seidel_converge(a: [int, float], b: [int, float], eps: [float]):
    '''
        Щодо різної ітерації.Тут у мене друге початкове наближення (нулі, там було - b) і точність різна.
        Матрична формула для нумпаю
        (норма з abs замість sqrt, можна поміняти, що і будемо робити в Method 3
        Що робить .join у Python?
        Метод Python String join()
        Метод join() бере всі елементи в ітерації та об’єднує їх в один рядок. Рядок має бути вказано як роздільник.
    '''
    n = len(a)
    x = np.zeros(n)  # zero vector

    converge = False  # converge-збігається
    while not converge:
        x_new = np.copy(x)
        for i in range(n):
            s1 = sum(a[i][j] * x_new[j] for j in range(i))
            s2 = sum(a[i][j] * x[j] for j in range(i + 1, n))
            x_new[i] = (b[i] - s1 - s2) / a[i][i]

        converge = np.sqrt(sum((x_new[i] - x[i]) ** 2 for i in range(n))) <= eps
        x = x_new
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')
    return x


# Method 3
def seidel_np(a: [int, float], b: [int, float]):
    x, y, n = b.copy(), np.zeros(b.size), 0
    U, L = -np.triu(a, 1), np.linalg.inv(np.tril(a))
    while np.abs(x - y).max() > 1e-4:
        x, y, n = L.dot(U.dot(x) + b), x, n + 1

    # print(f'{x=} ітерації={n}')
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')


# Метод простої ітерації (метод Якобі)
def jacobi(a: [int, float], b: [int, float], N: [int]=15, x=None):
    n = 0
    "Розв'язує рівняння Ax=b за допомогою ітераційного методу Якобі."
    # N - контрольована ітерація
    # Створіть початкове припущення, якщо потрібно
    if x is None:
        x = np.zeros(len(a[0]))

    # Створіть вектор діагональних елементів A
    # і відніміть їх від A
    D = np.diag(a)
    R = a - np.diagflat(D)

    # Ітерація N разів
    for i in range(N):
        x = (b - np.dot(R, x)) / D
        n += 1
    # Перевірка ітерації
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')
    return x


def smp_iter(a: [int, float], b: [int, float]):
    '''
        Наступна чисельна процедура просто повторюється для отримання вектора рішення
        ініціалізувати матрицю
        ініціалізувати вектор RHS
        друкує систему
        RHS – загальна математична абревіатура для "правої сторони".
        Тут, здається, ви вирішуєте систему лінійних рівнянь Ax = b, де A - це n x n матриця,
        а x і b - n-мірні вектори стовпців.
        Щодо коду, rhs - це масив, який використовується для ініціалізації елементів вектора b.
        Аналогічно, 2D-масив values
        використовується для ініціалізації елементів матриці A (фактично посилальної змінної з ім'ям A).
        Використовуючи отримані наближення, ітераційна процедура повторюється, поки не буде досягнута бажана точність.
    '''
    ITERATION_LIMIT = 1000
    print("Система:")
    for i in range(A.shape[0]):
        row = ["{}*x{}" .format(a[i, j], j + 1) for j in range(a.shape[1])]
        print(" + ".join(row), "=", b[i])
    print()
    n = 0
    x = np.zeros_like(b)
    for it_count in range(ITERATION_LIMIT):
        print("Актуальне рішення:", x)
        x_new = np.zeros_like(x)
        n += 1
        for i in range(a.shape[0]):
            s1 = np.dot(a[i, :i], x[:i])
            s2 = np.dot(a[i, i + 1:], x[i + 1:])
            x_new[i] = (b[i] - s1 - s2) / a[i, i]

        if np.allclose(x, x_new, atol=1e-4, rtol=0.):
            break
        x = x_new

    print("Рішення:", x.round(4))
    error = np.dot(a, x) - b
    print("Помилки:", error)
    print(f'Ітерації: {n=}')


a = np.array([[-0.76, -0.04, 0.21, -0.18], [0.45, -1.23, 0.66, 0.0],
              [0.26, 0.34, -1.11, 0.0], [0.05, -0.26, 0.34, -1.12]])
b = np.array([-1.24, 0.88, -0.63, 1.17])
print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
print("Method 1")
Seidel_dist(a, b)
print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
print('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
print("Method 2")
seidel_converge(a, b, 0.001)
print('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
print('/////////////////////////////////////////////////////////////////////////////////////////////////////////////')
print("Method 3")
seidel_np(a, b)
print('/////////////////////////////////////////////////////////////////////////////////////////////////////////////')
print('Метод простої ітерації (метод Якобі)')
guess = np.array([1e-4, 1e-4, 1e-4, 1e-4])
sol = jacobi(a, b, N=15, x=guess)
print("x:"); pprint(sol)
print("$smp_iter$")
smp_iter(a, b)
"""
elapsed_time = timeit.timeit(code_to_test, number=0)
print("Час виконання кода:", elapsed_time, 'ms')
#######################################################################################################################
'''
                        V                     VH               HV                     V
                         V                   V H               H V                   V
                          V                 V  H               H  V                 V
                           V               V   H               H   V               V
                            V             V    H               H    V             V
                             V           V     H               H     V           V
                              V         V      HHHHHHHHHHHHHHHHH      V         V
                               V       V       H               H       V       V
                                V     V        H               H        V     V
                                 V   V         H               H         V   V
                                  V V          H               H          V V
                                   V           H               H           V
'''
'''====================================================================================================================
                                            Лабороторна робота №2.Обчислення значень функції
Мета: закріплення знань із застосування точних та наближених методів
чисельного розв’язання систем лінійних алгебраїчних рівнянь (СЛАР).

Роботу виконував: Іванов Віктор Віталійович, ФФ-03
Роботу перевіряла: Гордійко Н.О.
Варіант №14
Завдання:
а) Користуючись методом Гаусса,розв'язати СЛАР:
    { 2x_1 - x_2 + x_3 = 0
    { 3x_1 + 3x_2 - 5x_3 = 1
    { x_1 + 3x_2 - 2x_3 = 4
б) Користуючись схемою Холецького, розв’язати СЛАР:
    { 9.1x_1 + 5.6x_2 + 7.8x_3 = 9.8
    { 3.8x_1 + 5.1x_2 + 2.8x_3 = 6.7
    { 4.1x_1 + 5.7x_2 + 1.2x_3 = 5.8
в) Методом квадратних коренів розв’язати СЛАР: 
    { x_1 + 0.5x_2 + 0.3333x_3 + 0.25x_4 = 1
    { 0.5x_1 + 0.3333x_2 + 0.25x_3 + 0.2x_4 = 0
    { 0.3333x_1 + 0.25x_2 + 0.2x_3  + 0.1667x_4 = 0
    { 0.25x_1 + 0.2x_2 + 0.1667x_3 + 0.1429x_4  = 0    
г)  Розв’язати СЛАР методом простої ітерації та методом Зейделя з точністю 1e-4
    Для кожного методу вивести кількість ітерацій, необхідних для розв’язання СЛАР:
    { -0.76x_1 - 0.04x_2 + 0.21x_3 - 0.18x_4 = -1.24
    {  0.45x_1 - 1.23x_2 + 0.66x_3 = 0.88
    {  0.26x_1 + 0.34x_2 - 1.11x_3 = -0.63
    {  0.05x_1 - 0.26x_2 + 0.34x_3 - 1.12x_4 = 1.17  
===================================================================================================================='''

'---------------------------------------------------------------------------------------------------------------------'
"Програмний код"
print("Завдання а)\n", "\tМетод Гаусса")

print('---------------------------------------------------------------------------------------------------------------')


def Gauss(X: [int, float], Y: [int, float]):
    Z = np.linalg.solve(X, Y)
    for i, e in enumerate(Z):
        print("Корені:", "x =", i, e)


X = np.matrix('2 -1 1; 3 3 -5; 1 3 -2')
Y = np.matrix('0; 1; 4')
Gauss(X, Y)
print('---------------------------------------------------------------------------------------------------------------')

print("Завдання б)")


def Choletskyi(G: [int, float], D: [int, float]):
    print("Перевірка симетричності:", np.all(G == G.T))
    H = np.linalg.solve(G, D)
    print(H)
    n = 3
    c = np.array([9.8, 6.7, 5.8])
    b = np.zeros((n, n))
    t = np.eye(n)
    y = np.zeros((n))
    x = np.zeros((n))

    for i in range(n):
        b[i][0] = G[i][0]
        t[0][i] = G[0][i] / b[0][0]

    for k in range(1, n):
        for i in range(k, n):
            s = 0
            for m in range(k):
                s = s + b[i][m] * t[m][k]
            b[i][k] = G[i][k] - s
        for j in range(k + 1, n):
            s = 0
            for m in range(k):
                s = s + b[k][m] * t[m][j]
            t[k][j] = (G[k][j] - s) / b[k][k]

    print("Матриця B:\n", b, "\n")
    print("Матриця C:\n", t, "\n")

    y[0] = c[0] / b[0][0]
    for i in range(1, n):
        s = 0
        for m in range(i):
            s = s + b[i][m] * y[m]
        y[i] = (c[i] - s) / b[i][i]
    print("Вектор y:\n", y, "\n")

    x[n - 1] = y[n - 1]
    for i in range(n - 1, -1, -1):
        s = 0
        for m in range(i + 1, n):
            s = s + t[i][m] * x[m]
        x[i] = y[i] - s
    print("Вектор x:\n", x, "\n")
    if H.all() == x.all():
        print("Метод Гаусса співпав з загальним методом Холецького:", True)
    else:
        print("Щось не так!")


G = np.array([[9.1, 5.6, 7.8],
              [3.8, 5.1, 2.8],
              [4.1, 5.7, 1.2]])
D = np.array([9.8, 6.7, 5.8])
Choletskyi(G, D)


print("Завдання с)\n", "\tМетод квадратних коренів")
print('##############################################################################################################')


def method_sqrt_roots(A: [float, int], B: [float, int]):
    '''
        Документація кода
        Вирішуємо систему Ax = B
        A = T'T
        Це розкладання може застосовуватися для вирішення системи лінійних рівнянь Ax = b,
        якщо матриця A симетрична та позитивно визначена. Такі матриці часто виникають,
        наприклад, при використанні методу найменших квадратів та чисельному розв'язанні диференціальних рівнянь.
        Якщо матриця системи є симетричною та позитивно визначеною,
        то для вирішення системи застосовують метод Холецького (метод квадратного коріння).
        В основі методу лежить алгоритм спеціального LU -розкладання матриці A ,
        внаслідок чого вона наводиться до виду A=LL'.
        Якщо розкладання отримано, те, як і методі LU -розкладання,
        рішення системи зводиться до послідовному розв'язанню двох систем з трикутними матрицями: і .
        Для знаходження коефіцієнтів матриці L невідомі коефіцієнти матриці прирівнюють відповідним елементам матриці A.
        Потім послідовно знаходять необхідні коефіцієнти за формулами:
        l_11 = sqrt(a_11),
        l_i1 = a_i1 / l_11, i = 2, 3, ..., m
        l_22 = sqrt(a_22 - (l_21)**2), l_i2 = (a_i2 - l_i1*l_21, i = 3, 4, ..., m
        l_kk = sqrt(a_kk - (l_k1)**2 - (l_k2)**2 -...-- (l_k,k-1)**2),
        l_ik = (a_ik - l_i1*l_k1 - l_i2*l_k2 - ... - l_ik-1,l_k,k-1)/l_kk, i = k+1, ..., m
        l_mm = sqrt(a_mm - (l_m1)**2 - (l_m2)**2 - ... - (l_m,m-1)**2)
    '''
    T = np.linalg.cholesky(A)
    print("Знайдемо розклад Холецького: \n", T)
    T_TRANSPOSE = T.transpose()
    print("Транспонована матриця:\n", T_TRANSPOSE)
    # T' * B = y
    # T_TRANSPOSE' * y  = x
    y = np.linalg.inv(T) * B
    x = np.linalg.inv(T_TRANSPOSE) * y
    print("Перевірка симетричності:", np.all(A == A.T))
    for index, el in enumerate(x.round(4)):
        print("Корені:", "x =", index, el)
    for ii, ell in enumerate(y.round(4)):
        print("Корені:", "y =", ii, ell)


A = np.matrix('1, 0.5, 0.3333, 0.25; 0.5, 0.3333, 0.25, 0.2; 0.3333, 0.25, 0.2, 0.1667; 0.25, 0.2, 0.1667, 0.1429')
B = np.matrix('1; 0; 0; 0')
method_sqrt_roots(A, B)
print('##############################################################################################################')

print("Завдання г)\n", "\tМетод простої ітерації та метод Зейделя")


# Ax = b. Метод Зейделя
# Method 1
def Seidel_dist(a: [int, float], b: [int, float]):
    '''
        Що таке dist () у Python?
        Метод dist() у Python використовується для визначення евклідової відстані між двома точками p і q,
        кожна з яких задана як послідовність (або повторювана) координат .
        Дві точки повинні мати однаковий розмір. Цей метод є новим у Python версії 3.8. Синтаксис: math.dist(p, q)
    '''
    x, y, n = b, [0] * len(b), 0
    while dist(x, y) > 1e-4:
        x, y, n = [0] * len(x), x, n + 1
        for i in range(len(y)):
            x[i] = 1 / a[i][i] * (b[i] -
                                  sum(x[j] * a[i][j] for j in range(i)) -
                                  sum(y[j] * a[i][j] for j in range(i + 1, len(y))))

    # x = (2.12, 0.76, 1.30, -0.73) итераций: 12
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')


# Method 2
def seidel_converge(a: [int, float], b: [int, float], eps: [float]):
    '''
        Щодо різної ітерації.Тут у мене друге початкове наближення (нулі, там було - b) і точність різна.
        Матрична формула для нумпаю
        (норма з abs замість sqrt, можна поміняти, що і будемо робити в Method 3
        Що робить .join у Python?
        Метод Python String join()
        Метод join() бере всі елементи в ітерації та об’єднує їх в один рядок. Рядок має бути вказано як роздільник.
    '''
    n = len(a)
    x = np.zeros(n)  # zero vector

    converge = False  # converge-збігається
    while not converge:
        x_new = np.copy(x)
        for i in range(n):
            s1 = sum(a[i][j] * x_new[j] for j in range(i))
            s2 = sum(a[i][j] * x[j] for j in range(i + 1, n))
            x_new[i] = (b[i] - s1 - s2) / a[i][i]

        converge = np.sqrt(sum((x_new[i] - x[i]) ** 2 for i in range(n))) <= eps
        x = x_new
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')
    return x


# Method 3
def seidel_np(a: [int, float], b: [int, float]):
    x, y, n = b.copy(), np.zeros(b.size), 0
    U, L = -np.triu(a, 1), np.linalg.inv(np.tril(a))
    while np.abs(x - y).max() > 1e-4:
        x, y, n = L.dot(U.dot(x) + b), x, n + 1

    # print(f'{x=} ітерації={n}')
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')


# Метод простої ітерації (метод Якобі)
def jacobi(a: [int, float], b: [int, float], N: [int]=15, x=None):
    n = 0
    "Розв'язує рівняння Ax=b за допомогою ітераційного методу Якобі."
    # N - контрольована ітерація
    # Створіть початкове припущення, якщо потрібно
    if x is None:
        x = np.zeros(len(a[0]))

    # Створіть вектор діагональних елементів A
    # і відніміть їх від A
    D = np.diag(a)
    R = a - np.diagflat(D)

    # Ітерація N разів
    for i in range(N):
        x = (b - np.dot(R, x)) / D
        n += 1
    # Перевірка ітерації
    print(f'x = ({", ".join(f"{xi:.4f}" for xi in x)}) ітерації: {n}')
    return x


def smp_iter(a: [int, float], b: [int, float]):
    '''
        Наступна чисельна процедура просто повторюється для отримання вектора рішення
        ініціалізувати матрицю
        ініціалізувати вектор RHS
        друкує систему
        RHS – загальна математична абревіатура для "правої сторони".
        Тут, здається, ви вирішуєте систему лінійних рівнянь Ax = b, де A - це n x n матриця,
        а x і b - n-мірні вектори стовпців.
        Щодо коду, rhs - це масив, який використовується для ініціалізації елементів вектора b.
        Аналогічно, 2D-масив values
        використовується для ініціалізації елементів матриці A (фактично посилальної змінної з ім'ям A).
        Використовуючи отримані наближення, ітераційна процедура повторюється, поки не буде досягнута бажана точність.
    '''
    ITERATION_LIMIT = 1000
    print("Система:")
    for i in range(A.shape[0]):
        row = ["{}*x{}" .format(a[i, j], j + 1) for j in range(a.shape[1])]
        print(" + ".join(row), "=", b[i])
    print()
    n = 0
    x = np.zeros_like(b)
    for it_count in range(ITERATION_LIMIT):
        print("Актуальне рішення:", x)
        x_new = np.zeros_like(x)
        n += 1
        for i in range(a.shape[0]):
            s1 = np.dot(a[i, :i], x[:i])
            s2 = np.dot(a[i, i + 1:], x[i + 1:])
            x_new[i] = (b[i] - s1 - s2) / a[i, i]

        if np.allclose(x, x_new, atol=1e-4, rtol=0.):
            break
        x = x_new

    print("Рішення:", x.round(4))
    error = np.dot(a, x) - b
    print("Помилки:", error)
    print(f'Ітерації: {n=}')


a = np.array([[-0.76, -0.04, 0.21, -0.18], [0.45, -1.23, 0.66, 0.0],
              [0.26, 0.34, -1.11, 0.0], [0.05, -0.26, 0.34, -1.12]])
b = np.array([-1.24, 0.88, -0.63, 1.17])
print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')
print("Method 1")
Seidel_dist(a, b)
print('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n')
print('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
print("Method 2")
seidel_converge(a, b, 0.001)
print('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
print('/////////////////////////////////////////////////////////////////////////////////////////////////////////////')
print("Method 3")
seidel_np(a, b)
print('/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n')
print('Метод простої ітерації (метод Якобі)')
guess = np.array([1e-4, 1e-4, 1e-4, 1e-4])
sol = jacobi(a, b, N=15, x=guess)
print("x:"); pprint(sol)
print("$smp_iter$")
smp_iter(a, b)

"""
Висновок: запрограмувавши різні математичні методи для вирішення СЛАР, ми отримали розв'язки та
порівняли який із методів може бути швидшим, надійнішим в точності значення та інше.Наприклад, так званий Метод Якобі 
широко використовується в розрахунках 
за методом кінцевих різниць (FDM), які є ключовою частиною кількісного фінансового ландшафту. PDE Блека-Шоулза можна 
сформулювати таким чином, щоб його можна було розв’язати методом кінцевих різниць. 
Метод Якобі є одним із способів розв’язання результуючого матричного рівняння, яке випливає з FDM..Ітераційний характер 
методу Якобі означає, 
що будь-яке збільшення швидкості в межах кожної ітерації може мати великий вплив на загальний розрахунок.
Важно також підмітити важливу примітку в методах Зейделя та простой ітерації.Проста ітерація повинна бути більшою за 
кількістю ітерації або дорівнювати числу ітерації Зейдельського метода.
Метод простої ітерацій і метод Зейделя майже ідентичні. 
Різниця полягає лише в тому, що в методі Зейделя розрахунок вектора 
наближень на поточній ітерації відбувається з використанням даних, 
отриманих не лише на попередній, а й на поточній ітерації. Іншими словами, в 
методі Зейделя дані для розрахунку вектора х надходять у порядку їх 
обчислення. А в методі простих ітерацій використовуються дані, отримані на 
попередній ітерації.
"""
